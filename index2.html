<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first Three.js app</title>
    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
		<style>
			body { margin: 0}
			canvas { width: 960; height: 500; }
		</style>
	</head>
	<body>
		<script>  
    
    var data = d3.csv("defaultData.csv", function (d){
      
    var scene, camera, renderer, controls, pcPlot;
    var depth = 100,
        width = 100,
        height = 100;
      
    function init(){
        scene = new THREE.Scene();
    
        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
        camera.position.z = 300;
        controls = new THREE.OrbitControls( camera );

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setClearColor( 0xf0f0f0 );
        
        pcPlot = new THREE.Object3D();
        scene.add(pcPlot);
        pcPlot.rotation.y = -0.4;

        document.body.appendChild( renderer.domElement );
    }
        
    function createTextCanvas(text, color, font, size) {
        size = size || 16;
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var fontStr = (size + 'px ') + (font || 'Arial');
        ctx.font = fontStr;
        var w = ctx.measureText(text).width;
        var h = Math.ceil(size);
        canvas.width = w;
        canvas.height = h;
        ctx.font = fontStr;
        ctx.fillStyle = color || 'black';
        ctx.fillText(text, 0, Math.ceil(size * 0.8));
        return canvas;
    }

    function createText2D(text, color, font, size, segW, segH) {
        var canvas = createTextCanvas(text, color, font, size);
        var plane = new THREE.PlaneGeometry(canvas.width, canvas.height, segW, segH);
        var tex = new THREE.Texture(canvas);
        tex.needsUpdate = true;
        var planeMat = new THREE.MeshBasicMaterial({
            map: tex,
            color: 0xffffff,
            transparent: true
        });
        var mesh = new THREE.Mesh(plane, planeMat);
        mesh.scale.set(0.5, 0.5, 0.5);
        mesh.doubleSided = true;
        return mesh;
    }
          
    function gridInit(depth,width,height){
        
        var planeXY = new THREE.GridHelper( height, 20, 0x000000, 0x000000 ),
            planeYZ = new THREE.GridHelper( depth, 20, 0x000000, 0x000000 ),
            planeXZ = new THREE.GridHelper( width, 20, 0x000000, 0x000000 );
        
        pcPlot.add(planeXY);
        pcPlot.add(planeYZ);
        pcPlot.add(planeXZ); 
        
        planeXY.position.y = -height;
        planeYZ.position.z = -depth;
        planeYZ.rotation.x = Math.PI/2;
        planeXZ.position.x = -width;
        planeXZ.rotation.z = Math.PI/2;
        
        var labelXZ = createText2D("PC1");
        pcPlot.add(labelXZ);
			     labelXZ.position.x = width*1.1;
			     labelXZ.position.y = -height;
        
        var labelXY = createText2D("PC2");
        pcPlot.add(labelXY);
			     labelXY.position.x = width*1.1;
			     labelXY.position.z = -depth;
        
        var labelYZ = createText2D("PC3");
        pcPlot.add(labelYZ);
			     labelYZ.position.x = -width*1.1;
			     labelYZ.position.z = depth;
    }
      
    function dotsInit(){
        geometry = new THREE.Geometry();
        //sprite = new THREE.TextureLoader().load( "textures/sprites/disc.png" );
        for ( i = 0; i < 10000; i ++ ) {
         var vertex = new THREE.Vector3();
         vertex.x = 2000 * Math.random() - 1000;
         vertex.y = 2000 * Math.random() - 1000;
         vertex.z = 2000 * Math.random() - 1000;
         geometry.vertices.push( vertex );
        }
        var material = new THREE.PointsMaterial({size: 35, sizeAttenuation: false} );
        material.color.setHSL( 1.0, 0.3, 0.7 );
        var particles = new THREE.Points( geometry, material );
        pcPlot.add( particles );
    }
    
    function render() {
        requestAnimationFrame( render );
        
        controls.update();
        
        renderer.render( scene, camera );
    }
    init();
    render();
    gridInit(depth,width,height);
    //dotsInit();  
    
    var unfiltered = [];
    d.forEach(function (d,i) {
            unfiltered[i] = {
                x: +d.x,
                y: +d.y,
                z: +d.z
            };
        })

    var xExent = d3.extent(unfiltered, function (d) {return d.x; }),
        yExent = d3.extent(unfiltered, function (d) {return d.y; }),
        zExent = d3.extent(unfiltered, function (d) {return d.z; });

    var vpts = {
        xMax: xExent[1],
        xCen: (xExent[1] + xExent[0]) / 2,
        xMin: xExent[0],
        yMax: yExent[1],
        yCen: (yExent[1] + yExent[0]) / 2,
        yMin: yExent[0],
        zMax: zExent[1],
        zCen: (zExent[1] + zExent[0]) / 2,
        zMin: zExent[0]
    }

    var colour = d3.scale.category20c();

    var xScale = d3.scale.linear()
                  .domain(xExent)
                  .range([-100,100]);
    var yScale = d3.scale.linear()
                  .domain(yExent)
                  .range([-100,100]);                  
    var zScale = d3.scale.linear()
                  .domain(zExent)
                  .range([-100,100]);
    
    var pointCount = unfiltered.length;
    
    
    var geometry = new THREE.Geometry();
        //sprite = new THREE.TextureLoader().load( "textures/sprites/disc.png" );
        for ( i = 0; i < pointCount; i ++ ) {
         var vertex = new THREE.Vector3();
         vertex.x = xScale(unfiltered[i].x);
         vertex.y = yScale(unfiltered[i].y);
         vertex.z = zScale(unfiltered[i].z);
         geometry.vertices.push( vertex );
        }
        var material = new THREE.PointsMaterial({size: 5, sizeAttenuation: false} );
        material.color.setHSL( 1.0, 0.3, 0.7 );
        var particles = new THREE.Points( geometry, material );
        pcPlot.add( particles );
    
    
    })  
    

    
      
		</script>
	</body>
</html>